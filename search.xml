<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据库系统概论第十章</title>
    <url>/2020/05/30/sql-chapter-10/</url>
    <content><![CDATA[<h1 id="第十章-数据库恢复技术"><a href="#第十章-数据库恢复技术" class="headerlink" title="第十章 数据库恢复技术"></a>第十章 数据库恢复技术</h1><h2 id="10-1-事物的基本概述"><a href="#10-1-事物的基本概述" class="headerlink" title="10.1 事物的基本概述"></a>10.1 事物的基本概述</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h3><p>所谓<strong>事务</strong>是用户定义的<strong>一个数据库操作序列</strong>，这些操作<strong>要么全做，要么全不做</strong>，是一个不可分割的工作单位。</p>
<p>例如，在关系数据库中，一个事务可以是一条SQL语句、一组SQL语句或整个程序。</p>
<p>事务和程序是两个概念。一般地讲，<strong>一个程序中包含多个事务</strong>。事务和程序是<strong>多对多</strong>的关系。</p>
<p><strong>定义事务</strong></p>
<ol>
<li><p>BEGIN TRANSACTION</p>
<p>事务的开始</p>
</li>
<li><p>COMMIT 表示提交，即提交事务的所有操作</p>
<p>事务正常结束</p>
</li>
<li><p>ROLLBACK 表示回滚</p>
<p>事务异常终止，系统将事务中对数据库的所有操作全部撤销，回滚到事务开始时的状态。</p>
</li>
</ol>
<h3 id="2-事务的特性（ACID）"><a href="#2-事务的特性（ACID）" class="headerlink" title="2. 事务的特性（ACID）"></a>2. 事务的特性（ACID）</h3><ul>
<li><p><strong>原子性 A</strong></p>
<p>事务是数据库的逻辑工作单位，事务中包括的诸操作<strong>要么都做，要么都不做</strong>。</p>
</li>
<li><p><strong>一致性 C</strong></p>
<p>事务执行的结果必须是使数据库从一个<strong>一致性状态</strong>变到<strong>另一个一致性状态</strong>。</p>
<p>一致性状态：数据库中只包含成功事务提交的结果</p>
<p>不一致状态：数据库中包含失败事务的结果</p>
</li>
<li><p><strong>隔离性 I</strong></p>
<p><strong>一个事务的执行不能被其他事务干扰</strong>。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持续性 D</strong></p>
<p>持续性也称永久性（Permanence），一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</p>
</li>
</ul>
<p>事务恢复和并发控制的基本单位。</p>
<p>保证事务ACID特性是事务管理的重要任务。事务ACID特性可能遭到破坏的因素有：</p>
<ol>
<li>多个事务并行运行时，不同事物的操作交叉执行</li>
<li>事务在运行过程中被强行停止</li>
</ol>
<h2 id="10-2-数据库恢复概述"><a href="#10-2-数据库恢复概述" class="headerlink" title="10.2 数据库恢复概述"></a>10.2 数据库恢复概述</h2><p>故障是不可避免的（系统故障：计算机软、硬件故障，人为故障：操作员的失误、恶意的破坏等）。</p>
<p>数据库的恢复：把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）。</p>
<p>防止数据库的安全性和完整性被破坏。</p>
<p>故障的影响</p>
<ol>
<li><p>运行事务非正常中断</p>
</li>
<li><p>破坏数据库</p>
</li>
</ol>
<p>数据库管理系统应对故障的对策</p>
<ol>
<li><p>DBMS提供恢复子系统</p>
</li>
<li><p>保证故障发生后，能把数据库中的数据从错误状态恢复到某种逻辑一致的状态</p>
</li>
<li><p>保证事务ACID</p>
</li>
</ol>
<p>恢复技术是衡量数据库系统优劣的重要指标</p>
<h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a>10.3 故障的种类</h2><h3 id="1-事务内部的故障"><a href="#1-事务内部的故障" class="headerlink" title="1. 事务内部的故障"></a>1. 事务内部的故障</h3><p>有的是可以通过事务程序本身发现的，有的是非预期的，无法由事务程序处理。</p>
<p>事务内部更多的故障是<strong>非预期的</strong>，是不能由应用程序处理的。</p>
<p>事务故障的恢复：<strong>事务撤销（UNDO）</strong></p>
<h3 id="2-系统故障"><a href="#2-系统故障" class="headerlink" title="2. 系统故障"></a>2. 系统故障</h3><p>称为<strong>软故障</strong>，是指<strong>造成系统停止运转</strong>的任何事件，使得系统要重新启动。 例如，CPU故障、操作系统故障、DBMS故障、系统断电等，这类故障影响正在运行的所有事务，<strong>但不破坏数据库</strong>。</p>
<p>发生故障时，事务未提交 —— <strong>强行撤销</strong>（UNDO）所有未完成事务</p>
<p>发生故障时，事务已提交，但缓冲区中的信息尚未完全写回到磁盘中 —— <strong>重做</strong>（REDO）所有已提交的事务</p>
<h3 id="3-介质故障"><a href="#3-介质故障" class="headerlink" title="3. 介质故障"></a>3. 介质故障</h3><p>称为<strong>硬故障</strong>，指<strong>外存故障</strong>，如磁盘损坏、磁头碰撞等，这类故障将破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。这类故障比前两类发生的可能性小得多，但破坏性最大。</p>
<h3 id="4-计算机病毒"><a href="#4-计算机病毒" class="headerlink" title="4. 计算机病毒"></a>4. 计算机病毒</h3><p>计算机病毒是<strong>一种人为的故障或破坏</strong>，是一些恶作剧者研制的一种计算机程序。可以繁殖和传播，并打造成对计算机系统包括数据库的危害。</p>
<h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a>10.4 恢复的实现技术</h2><p>恢复操作的基本原理：<strong>冗余</strong></p>
<p>两个关键问题：</p>
<ol>
<li><p>如何建立冗余数据：</p>
<ul>
<li><p><strong>数据转储</strong>（backup）</p>
</li>
<li><p><strong>登录日志文件</strong>（logging）</p>
</li>
</ul>
</li>
<li><p>如何利用这些冗余数据实施数据库恢复</p>
</li>
</ol>
<h3 id="10-4-1-数据转储"><a href="#10-4-1-数据转储" class="headerlink" title="10.4.1 数据转储"></a>10.4.1 数据转储</h3><p>数据转储是数据库恢复中采用的基本技术。所谓<strong>转储</strong>是指DBA将整个数据库复制到磁带或另一个磁盘上<strong>保存起来</strong>的过程，备用的数据称为<strong>后备副本</strong>或后援副本。</p>
<p>重装后备副本只能将数据库恢复到转储时的状态。</p>
<p>使用：</p>
<ul>
<li><p>数据库遭到破坏后可以将后备副本重新装入</p>
</li>
<li><p>重装后备副本只能将数据库恢复到转储时的状态</p>
</li>
</ul>
<h4 id="静态转储"><a href="#静态转储" class="headerlink" title="静态转储"></a>静态转储</h4><p>静态转储是在系统中无运行事务时进行的转储操作。即转储开始时数据库处于一致性状态，转储期间不允许对数据库的任何存取、修改活动。静态转储得到的一定是一个数据一致性的副本。</p>
<p>优点：实现简单</p>
<p>缺点：降低了数据库的可用性，转储必须等待正运行的用户事务结束才能进行，新的事务必须等转储结束才能执行</p>
<h4 id="动态转储"><a href="#动态转储" class="headerlink" title="动态转储"></a>动态转储</h4><p>动态转储是指转储期间允许对数据库进行存取或修改。即转储和用户事务可以并发执行。</p>
<p>优点：不用等待正在运行的用户事务结束，不会影响新事务的运行。</p>
<p>缺点：不能保证副本中的数据正确有效。</p>
<p><strong>利用动态转储得到的副本进行故障恢复：</strong></p>
<ul>
<li><p>需要把动态转储期间各事务对数据库的修改活动登记下来，建立<strong>日志文件</strong></p>
</li>
<li><p><strong>后备副本</strong>加上<strong>日志文件</strong>才能把数据库恢复到某一时刻的正确状态</p>
</li>
</ul>
<h4 id="海量转储"><a href="#海量转储" class="headerlink" title="海量转储"></a>海量转储</h4><p>每次转储全部数据库。</p>
<h4 id="增量转储"><a href="#增量转储" class="headerlink" title="增量转储"></a>增量转储</h4><p>只转储上次转储后更新过的数据。</p>
<h4 id="转储策略"><a href="#转储策略" class="headerlink" title="转储策略"></a>转储策略</h4><p>应定期进行数据转储，制作后备副本。</p>
<p>但转储又是十分耗费时间和资源的，不能频繁进行。</p>
<p>DBA应该根据数据库使用情况确定适当的转储周期和转储方法。</p>
<blockquote>
<p>例：</p>
<ul>
<li><p>每天晚上进行动态增量转储</p>
</li>
<li><p>每周进行一次动态海量转储</p>
</li>
<li><p>每月进行一次静态海量转储</p>
</li>
</ul>
</blockquote>
<h3 id="10-4-2-登录日志文件"><a href="#10-4-2-登录日志文件" class="headerlink" title="10.4.2 登录日志文件"></a>10.4.2 登录日志文件</h3><h4 id="1-日志文件的格式和内容"><a href="#1-日志文件的格式和内容" class="headerlink" title="1. 日志文件的格式和内容"></a>1. 日志文件的格式和内容</h4><p>日志文件是用来<strong>记录事务对数据库的更新操作</strong>的文件。日志文件主要由两种格式：以记录为单位的日志文件 和 以数据块为单位的日志文件。</p>
<h5 id="a-以记录为单位"><a href="#a-以记录为单位" class="headerlink" title="a. 以记录为单位"></a>a. 以记录为单位</h5><p>日志文件中<strong>需要登记的内容</strong>包括：</p>
<ul>
<li><p>各个事务的开始（BEGIN TRANSACTION）标记。</p>
</li>
<li><p>各个事务的结束（COMMIT或ROLLBACK）标记。</p>
</li>
<li><p>各个事务的所有更新操作。</p>
</li>
</ul>
<p>这里每个事务的开始标记、每个事务的结束标记和每个更新操作均作为日志文件中的<strong>一个日志记录</strong></p>
<p><strong>每条日志记录</strong>的内容：</p>
<ul>
<li>事务标识（标明是哪个事务） </li>
<li>操作类型（插入、删除或修改）</li>
<li>操作对象（记录内部标识）</li>
<li>更新前数据的旧值（对插入操作而言，此项为空值）</li>
<li>更新后数据的新值（对删除操作而言, 此项为空值）</li>
</ul>
<h5 id="b-以数据块为单位"><a href="#b-以数据块为单位" class="headerlink" title="b. 以数据块为单位"></a>b. 以数据块为单位</h5><p>对于以数据块为单位的日志文件，<strong>每条日志记录的内容</strong>包括：</p>
<ul>
<li>事务标识（标明是那个事务）</li>
<li>被更新的数据块</li>
</ul>
<p>由于将更新前的整个块和更新后的整个块都放入日志文件中，操作类型和操作对象等信息就不必放入日志记录中了。</p>
<h4 id="2-日志文件的作用"><a href="#2-日志文件的作用" class="headerlink" title="2. 日志文件的作用"></a>2. 日志文件的作用</h4><ul>
<li><p>进行事务故障恢复</p>
</li>
<li><p>进行系统故障恢复</p>
</li>
<li><p>协助后备副本进行介质故障恢复</p>
</li>
</ul>
<h4 id="3-登记日志文件"><a href="#3-登记日志文件" class="headerlink" title="3. 登记日志文件"></a>3. 登记日志文件</h4><p><strong>为保证数据库是可恢复的</strong>，登录日志文件时，必须遵循<strong>两条原则</strong>：</p>
<ul>
<li>登记的次序严格按并行事务执行的时间次序</li>
<li>必须先写日志文件，后写数据库</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概论第六章</title>
    <url>/2020/06/02/sql-chapter-6/</url>
    <content><![CDATA[<h1 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h1><h2 id="6-1-问题的提出"><a href="#6-1-问题的提出" class="headerlink" title="6.1 问题的提出"></a>6.1 问题的提出</h2><p>在第2章关系数据库中已经讲过，一个关系模式应当是一个五元组。 </p>
<script type="math/tex; mode=display">
R(U,D,DOM,F)</script><p>这里：</p>
<ul>
<li>关系名R是符号化的元组语义。</li>
<li>U为一组属性。</li>
<li>D为属性组U中的属性所来自的域。</li>
<li>DOM为属性到域的映射。</li>
<li>F为属性U上的一组数据依赖。</li>
</ul>
<p>在本章中把关系模式看作一个<strong>三元组</strong>：</p>
<script type="math/tex; mode=display">
R(U,F)</script><p>当且仅当U上的一个关系r满足F时，r称为关系模式R<U,F>的一个<strong>关系</strong>。</p>
<p>作为一个<strong>二维表</strong>，关系要符合一个最基本的条件：每一个分量必须是不可分的数据项。满足了这个条件的关系模式就属于<strong>第一范式（1NF）</strong>。</p>
<p>数据依赖的类型有多种，其中最重要的是 <strong>函数依赖</strong> 和 <strong>多值依赖</strong> 。</p>
<p>关系模式存在的问题：</p>
<ol>
<li>数据冗余太大</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常</li>
</ol>
<p><strong>一个好的模式应当不会发生插入异常、删除异常、和更新异常，数据冗余应尽可能少。</strong></p>
<h2 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h2><h3 id="6-2-1-函数依赖"><a href="#6-2-1-函数依赖" class="headerlink" title="6.2.1 函数依赖"></a>6.2.1 函数依赖</h3><p><strong>定义</strong>：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系 r，r 中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称 “X函数确定Y” 或  “Y函数依赖于X”，记作 X→Y。</p>
<blockquote>
<p> <strong>注意</strong>：函数依赖不是指关系模式R的某个或某些关系满足的约束条件，而是指R的一切关系均要满足的约束条件。</p>
</blockquote>
<ul>
<li><p>$X\rightarrow Y$，但 $Y\nsubseteq X$，则称 $X\rightarrow Y$ 是非平凡的函数依赖。</p>
</li>
<li><p>$X\rightarrow Y$，但$Y\subseteq X$，则称 $X\rightarrow Y$ 是平凡的函数依赖。</p>
</li>
<li><p>若 $X\rightarrow Y$，则 $X$ 称为这个函数依赖的决定属性组，也成为<strong>决定因素</strong>。</p>
</li>
<li><p>若 $X\rightarrow Y$，$Y\rightarrow X$，则记作 $X\leftarrow\rightarrow Y$。</p>
</li>
<li><p>若Y不函数依赖于X，则记作 $X\nrightarrow Y$。</p>
</li>
</ul>
<p>在R(U)中，如果 $X\rightarrow Y$，并且对于X的任何一个真子集X’，都有$X’\rightarrow Y$，则称Y对X<strong>完全函数依赖</strong>。</p>
<p>若 $X\rightarrow Y$，但Y不完全函数依赖于X，则称Y对X<strong>部分函数依赖</strong>。</p>
<p>传递函数依赖，直接函数依赖</p>
<h3 id="6-2-2-码"><a href="#6-2-2-码" class="headerlink" title="6.2.2 码"></a>6.2.2 码</h3><p><strong>码是关系模式中的一个重要概念。</strong></p>
<p>定义：设K为R<U,F>中的属性或属性组合，若U<strong>完全函数依赖于</strong>K，则K为R的侯选码。若候选码多于一个，则选定其中的一个做为主码。</p>
<p>包含在任何一个候选码中的属性称为<strong>主属性</strong>；不包含在任何候选码中的属性称为<strong>非主属性</strong>或<strong>非码属性</strong>。</p>
<h3 id="6-2-3-范式"><a href="#6-2-3-范式" class="headerlink" title="6.2.3 范式"></a>6.2.3 范式</h3><p>关系数据库中的关系必须是要满足一定的要求，满足不同程度要求的为不同范式。满足最低要求的叫第一范式，简称1NF；在第一范式中满足进一步要求的为第二范式，其余以此类推。</p>
<p>范式是符合某一种级别的关系模式的集合。即R为第几范式就可以写成 $R\in xNF$。</p>
<p>各范式之间的关系有：</p>
<script type="math/tex; mode=display">
5NF\subset 4NF\subset BCNF\subset 3NF\subset 2NF\subset 1NF</script><p>5NF规范化程度最高。</p>
<p>一个低一级范式的关系模式，通过<strong>模式分解</strong>可以转换为若干个高一级范式的关系模式的集合，这种过程就叫<strong>规范化</strong>。</p>
<h3 id="6-2-4-2NF"><a href="#6-2-4-2NF" class="headerlink" title="6.2.4 2NF"></a>6.2.4 2NF</h3><p>定义：若 $R\in 1NF$，且每一个 <strong>非主属性</strong> <strong>完全函数依赖于</strong> 任何一个候选码，则 $R\in 2NF$。</p>
<p>2NF在1NF的基础上消除了非主属性对码的部分函数依赖。</p>
<h3 id="6-2-5-3NF"><a href="#6-2-5-3NF" class="headerlink" title="6.2.5 3NF"></a>6.2.5 3NF</h3><p>若 $R\in 3NF$，则每一个 <strong>非主属性</strong> 既 <strong>不传递依赖于码</strong>，也<strong>不部分依赖于码</strong>。</p>
<p>如果R属于3NF，则必有R属于2NF。</p>
<p>3NF在2NF的基础上又消除了非主属性对码的传递函数依赖。</p>
<h3 id="6-2-6-BCNF"><a href="#6-2-6-BCNF" class="headerlink" title="6.2.6 BCNF"></a>6.2.6 BCNF</h3><p>定义：关系模式 R<U,F> ∈ 1NF，若 X $\rightarrow$ Y 且 Y $\nsubseteq$ X 时 X 必含有码，则 R<U,F> ∈ BCNF。</p>
<p>也就是说，关系模式 R<U,F> 中，若<strong>每一个决定因素都包含码</strong>，则 R<U,F> ∈ BCNF。</p>
<p>若R∈BCNF，则有结论：</p>
<ul>
<li>所有非主属性对每一个码都是完全函数依赖</li>
<li>所有主属性对每一个不包含它的码也是完全函数依赖</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性</li>
</ul>
<p>由于R∈BCNF，按定义排除了任何属性对码的传递依赖与部分依赖，所以R∈3NF。</p>
<p>但是若R∈3NF，R未必属于BCNF。</p>
<p>如果R∈3NF，且R只有一个候选码，则R∈BCNF是R∈3NF的充分必要条件。</p>
<p>BCNF消除了主属性对码的部分函数依赖和传递函数依赖。</p>
<h3 id="6-2-7-多值依赖"><a href="#6-2-7-多值依赖" class="headerlink" title="6.2.7 多值依赖"></a>6.2.7 多值依赖</h3><p>定义：设R(U)是一个属性集U上的一个关系模式，X、Y、Z是U的子集，并且Z＝U－X－Y。关系模式R(U)中<strong>多值依赖</strong> X→→Y 成立，<strong>当且仅当</strong>对R(U)的任一关系r，给定的一对（x，z）值，有一组Y的值，这组值仅仅决定于x值而与z值无关。</p>
<p>若 X→→Y，而 Z＝φ，即Z为空，则称 X→→Y 为<strong>平凡的多值依赖</strong>，否则称 X→→Y 为<strong>非平凡的多值依赖</strong>。</p>
<p>多值依赖具有以下性质：</p>
<ul>
<li><p>多值依赖具有<strong>对称性</strong>。即若X→→Y，则X→→Z，其中Z＝U－X－Y。</p>
</li>
<li><p>多值依赖具有<strong>传递性</strong>。即若X→→Y，Y→→Z， 则X→→Z–Y。</p>
</li>
<li><p>函数依赖是多值依赖的特殊情况，若X→Y，则X→→Y。</p>
</li>
</ul>
<ul>
<li>若X→→Y，X→→Z，则X→→Y∩Z。（交）</li>
</ul>
<ul>
<li>若X→→Y，X→→Z，则X→→Y∪Z。（并）</li>
</ul>
<ul>
<li>若X→→Y，X→→Z，则X→→Y-Z，X→→Z-Y。（差）</li>
</ul>
<p>多值依赖与函数依赖的区别：</p>
<ul>
<li><strong>多值依赖的有效性与属性集的范围有关。</strong> 若多值依赖 X→→Y 若在 R(U) 上成立，则在 $W(XY\subseteq W\subseteq U)$ 上一定成立；反之则不然，即 X→→Y 在 $W(W\subset U)$ 上成立，在 U 上并不一定成立。</li>
<li>若函数依赖X→Y在R(U)上成立，则对于<strong>任何</strong> $Y’\subset Y$ 均有 X→Y’ <strong>成立</strong>。而多值依赖X→→Y若在R(U)上成立，<strong>不能断言</strong>对于任何 $Y’\subset Y$ 有 X→→Y’ 成立。</li>
</ul>
<h3 id="6-2-8-4NF"><a href="#6-2-8-4NF" class="headerlink" title="6.2.8 4NF"></a>6.2.8 4NF</h3><p>定义：关系模式R<U,F>∈1NF，如果对于R的每个<strong>非平凡多值依赖</strong> X→→Y（Y $\nsubseteq$ X），<strong>X 都含有码</strong>，则R∈4NF。</p>
<p>4NF就是限制关系模式的属性之间不允许有<strong>非平凡且非函数依赖</strong>的多值依赖。</p>
<p>4NF所<strong>允许的非平凡的多值依赖实际上是函数依赖</strong>。</p>
<p>如果R ∈ 4NF，则R ∈ BCNF。</p>
<p>可用<strong>投影分解</strong>的方法消去非平凡且非函数依赖的多值依赖。</p>
<h3 id="6-2-9-规范化小结"><a href="#6-2-9-规范化小结" class="headerlink" title="6.2.9 规范化小结"></a>6.2.9 规范化小结</h3><p>在关系数据库中，对关系模式的基本故要求是满足第一范式，这样的关系模式就是合法的、允许的。</p>
<p>关系数据库的规范化理论是数据库逻辑设计的工具。</p>
<p>目的：尽量消除插入、删除异常，修改复杂，数据冗余。</p>
<p>基本思想：逐步消除数据依赖中不合适的部分。</p>
<p>实质：概念的<strong>单一化</strong>。</p>
<p>关系模式规范化的基本步骤：</p>
<p><img src="https://s1.ax1x.com/2020/06/02/tNpm0e.png" alt="规范化过程"></p>
<p>不能说规范化程度越高的关系模式就越好。在设计数据库模式结构时，必须对现实世界的实际情况和用户应用需求作进一步分析，确定一个合适的、能够反映现实世界的模式。上面的规范化步骤可以在其中任何一步终止。</p>
<p><strong>关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高一级的关系模式。</strong>这种分解不是唯一的。</p>
<h2 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a>6.3 数据依赖的公理系统</h2><p><strong>逻辑蕴涵定义</strong>：对于满足一组函数依赖 F 的关系模式 R<U,F>，其任何一个关系 r，若函数依赖 X→Y 都成立，（即 r 中任意两元组t，s，若t[X]=s[X]，则t[Y]=s[Y]），则称<strong>F逻辑蕴含X→Y</strong>。</p>
<p>Armstrong公理系统设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R<U,F >，对R<U,F >来说有以下的<strong>推理规则</strong>：</p>
<ul>
<li><p><strong>A1. 自反律</strong>（Reflexivity）：若Y $\subseteq$ X $\subseteq$ U，则X→Y为F所蕴含。（由自反律所得到的的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F）</p>
</li>
<li><p><strong>A2. 增广律</strong>（Augmentation）：若X→Y为F所蕴含，且Z $\subseteq$ U，则XZ→YZ为F所蕴含。（这里XZ代表X∪Z，YZ代表Y∪Z）</p>
</li>
<li><p><strong>A3. 传递律</strong>（Transitivity）：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含。</p>
</li>
</ul>
<p>证明略（课本P190）。</p>
<p>根据A1，A2，A3这三条推理规则可以得到下面<strong>三条推理规则</strong>：</p>
<ul>
<li><p>合并规则：由X→Y，X→Z，有X→YZ。</p>
<p>（A2， A3）</p>
</li>
<li><p>伪传递规则：由X→Y，WY→Z，有XW→Z。</p>
<p>（A2， A3）</p>
</li>
<li><p>分解规则：由X→Y及 Z $\subseteq$ Y，有X→Z。</p>
<p>（A1， A3）</p>
</li>
</ul>
<p><strong>引理6.1</strong>：$X\rightarrow A_1A_2\cdots A_k$ 成立的充分必要条件是 $X\rightarrow A_i$ 成立（$i=1,2,\cdots,k$）。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令学习</title>
    <url>/2020/04/17/linux-command/</url>
    <content><![CDATA[<p>2020年春大二下学期，我们开设了操作系统课程，开始接触Linux，用这篇文章记录学习到的命令。  </p>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">Linux 命令大全 | 菜鸟教程</a> ——列出了很多命令，有详细说明</p>
<p><a href="https://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全(手册)</a> ——可以搜索某个命令的用法和解释</p>
<h2 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>切换当前工作目录至 dirName(目录参数)。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">cd [dirName]
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>dirName：要切换的目标目录。</li>
<li>若省略 dirName，则变换至使用者的 home 目录</li>
<li>另外，”~” 也表示 home 目录，”.” 表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</li>
</ul>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>显示当前所在的工作目录。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">pwd
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。它有很多参数可用。比如：</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ls
ls -a
ls -l
ls -all
ls fileName -l
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<p>Quick Start</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo server
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo generate
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ hexo deploy
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>软件工程概论第一章笔记</title>
    <url>/2020/05/14/software-engineering-1/</url>
    <content><![CDATA[<blockquote>
<p>教材：软件工程——原理、方法与应用（第3版）</p>
</blockquote>
<h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><h3 id="1-1-软件和软件危机"><a href="#1-1-软件和软件危机" class="headerlink" title="1.1 软件和软件危机"></a>1.1 软件和软件危机</h3><h4 id="1-1-1-软件的定义"><a href="#1-1-1-软件的定义" class="headerlink" title="1.1.1 软件的定义"></a>1.1.1 软件的定义</h4><p><strong>软件</strong>是能够完成预定功能和性能的可执行的计算机程序和使程序正常执行所需要的数据，加上描述程序的操作和使用的文档</p>
<p><strong>软件 = 程序 + 数据 + 文档</strong></p>
<p><strong>程序</strong>是按事先设计的功能和性能要求执行的指令序列<br><strong>数据</strong>是使程序能正常操纵信息的数据结构<br><strong>文档</strong>是与程序开发，维护和使用有关的图文材料</p>
<h4 id="1-1-2-软件的特征"><a href="#1-1-2-软件的特征" class="headerlink" title="1.1.2 软件的特征"></a>1.1.2 软件的特征</h4><p>软件是逻辑的而不是物理的，是一种<strong>逻辑实体</strong></p>
<ol>
<li><p>软件开发不同于硬件设计</p>
<p>软件开发的成本很难估计，通常占整个生产成本的大部分</p>
</li>
<li><p>软件生产不同于硬件制造</p>
<p>在它的开发过程中没有明显的制造过程</p>
</li>
<li><p>软件维护不同于软件维修</p>
<p>软件没有硬件那样的机械磨损，老化问题，但在使用过程中的维护却比硬件复杂的多。如果软件内部的逻辑关系比较复杂或规模比较大，在维护过程中很可能产生新的错误</p>
</li>
</ol>
<h4 id="1-1-3-软件危机"><a href="#1-1-3-软件危机" class="headerlink" title="1.1.3 软件危机"></a>1.1.3 软件危机</h4><p>定义：在软件开发和维护过程中所存在一系列严重问题（开发费用超出预算、完成时间拖期、软件可靠性往往随着规模的增长而下降，质量差）</p>
<p>原因（从<strong>维护</strong>和<strong>生产</strong>两个方面）</p>
<ol>
<li><p>软件维护费用急剧上升，直接威胁计算机应用的扩大</p>
<p>纠错性维护、完善性性维护、适应性维护</p>
</li>
<li><p>软件生产技术进步缓慢，是加剧软件危机的重要原因</p>
</li>
</ol>
<h3 id="1-2-软件工程学范畴"><a href="#1-2-软件工程学范畴" class="headerlink" title="1.2 软件工程学范畴"></a>1.2 软件工程学范畴</h3><p>宗旨：摆脱软件危机，谋求解决这一危机的方法。<br>中心思想：把软件当作一种工业产品，用工程的方法进行开发</p>
<h4 id="1-2-1-软件开发方法学"><a href="#1-2-1-软件开发方法学" class="headerlink" title="1.2.1 软件开发方法学"></a>1.2.1 软件开发方法学</h4><ul>
<li><p>早期的程序设计</p>
<p>   追求程序设计技巧和效率，程序员各行其是，无统一标准</p>
</li>
<li><p>结构化程序设计</p>
<p>   三种基本程序结构，自顶向下、逐步细化的开发方法，形成“结构化分析”、“结构化设计”传统方法</p>
</li>
<li><p>面向对象的程序设计</p>
<p>   引入对象、类、继承等概念，形成构件，达到软件复用的目的</p>
</li>
</ul>
<h4 id="1-2-2-软件工具"><a href="#1-2-2-软件工具" class="headerlink" title="1.2.2 软件工具"></a>1.2.2 软件工具</h4><p>帮助开发和维护软件的软件</p>
<p>编译程序、编辑程序、连接程序以及支持他们的计算机操作系统，都属于软件工具</p>
<p>另外还有：分析工具、设计工具、测试工具、维护工具</p>
<h4 id="1-2-3-软件工程环境"><a href="#1-2-3-软件工程环境" class="headerlink" title="1.2.3 软件工程环境"></a>1.2.3 软件工程环境</h4><p>方法与工具相结合，再加上配套的软、硬件支持就形成环境。</p>
<h4 id="1-2-4-软件工程管理"><a href="#1-2-4-软件工程管理" class="headerlink" title="1.2.4 软件工程管理"></a>1.2.4 软件工程管理</h4><p>软件工程管理的目的，是为了按照进度及预算完成软件开发计划，实现预期的经济和社会效益。它包括成本估算<br>进度安排、人员组织和质量保证等多方面的内容，还涉及管理学、度量学和经济学等多个学科方面的知识。</p>
<p>一个理想的软件工程环境，应该同时具备支持开发和支持管理两个方面的工具。</p>
<h3 id="1-3-软件工程的发展"><a href="#1-3-软件工程的发展" class="headerlink" title="1.3 软件工程的发展"></a>1.3 软件工程的发展</h3><h4 id="1-3-1-3种编程范型"><a href="#1-3-1-3种编程范型" class="headerlink" title="1.3.1 3种编程范型"></a>1.3.1 3种编程范型</h4><ol>
<li><p>过程式编程范型</p>
<p>程序 = 数据结构 + 算法</p>
</li>
<li><p>面向对象编程范型</p>
<p>程序 = 对象 + 消息</p>
</li>
<li><p>基于构件技术的编程范型</p>
<p>构件：标准化的对象类。</p>
</li>
</ol>
<h4 id="1-3-2-3代软件工程"><a href="#1-3-2-3代软件工程" class="headerlink" title="1.3.2 3代软件工程"></a>1.3.2 3代软件工程</h4><p>软件工程的分代</p>
<ol>
<li><p>传统的软件工程</p>
<p>以结构化的程序设计为基础</p>
</li>
<li><p>面向对象的软件工程</p>
<p>以面向对象的程序设计为基础</p>
</li>
<li><p>基于构件的软件工程</p>
<p>以软件复用为目标、领域工程为基础</p>
</li>
</ol>
<h3 id="1-4-软件工程的应用"><a href="#1-4-软件工程的应用" class="headerlink" title="1.4 软件工程的应用"></a>1.4 软件工程的应用</h3><p>略</p>
]]></content>
      <categories>
        <category>软件工程概论</category>
      </categories>
      <tags>
        <tag>软件工程概论</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Hexo搭建博客</title>
    <url>/2020/04/15/blog-hexo/</url>
    <content><![CDATA[<p>在家闲来无事（其实是一直在家憋得慌）就搭了这个博客，太麻烦了，这么多配置的坑一个一个填，现在还没把小图标不显示的问题解决</p>
<p>2020.2.15 23:32</p>
<p>解决了小图标的问题，小图标的问题是icon图标名称前的 <code>fa fa-xxx</code> 前缀的原因，我之前以为fa是多余的就都给删了，重新下载了一次 NexT 主题，默认的东西都没动，图标名称也没动。现在我也是在尝试着一点一点完善这个博客，感觉挺好玩的。</p>
<p>我感觉 Hexo 搭建博客操作是比较简单的，但是写博客上传是比较麻烦的，要在本地命令行进行，我现在刚开始只有一两篇文章部署的速度还是很快的，但是以后文章数量多了的话我也不知道速度会怎么样。</p>
<p>之后会抽时间把自己用 Hexo 搭建博客的这个过程给完整记录下来，遇到的问题也会整理一下。</p>
<hr>
<h2 id="Hexo-搭建过程"><a href="#Hexo-搭建过程" class="headerlink" title="Hexo 搭建过程"></a>Hexo 搭建过程</h2><p>可以点击查看 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo 官方文档</a> ，中文版的。</p>
<h3 id="GitHub-创建个人仓库"><a href="#GitHub-创建个人仓库" class="headerlink" title="GitHub 创建个人仓库"></a>GitHub 创建个人仓库</h3><p>在 GitHub 首页右上角头像旁点击 “➕”，然后 New repository 创建新仓库，Repository name 写成 username.github.io 的形式，这里的 username 需要和你的 GitHub 用户名<strong>相同</strong>，比如我的 GitHub 用户名是 liuzhihan0，那我创建的仓库名就是 liuzhihan0.github.io ，仓库名填写好后，点击 Create repository 即可。</p>
<h3 id="安装-Node-js-和-Git"><a href="#安装-Node-js-和-Git" class="headerlink" title="安装 Node.js 和 Git"></a>安装 Node.js 和 Git</h3><p>用 Github + Hexo 搭建博客需要用到 Node.js 和 Git 。</p>
<blockquote>
<p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></p>
</blockquote>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>安装好 Git 后，需要进行下面的配置。<br>打开 Git Bush 终端进行操作，设置 user.name 和 user.email 配置信息，这里设置为全局。</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">git config --global user.name "你的GitHub用户名"
git config --global user.email "你的GitHub注册邮箱"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>加引号。</p>
<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>通过注册的邮箱生成 ssh 密钥文件，这个同样在 Git Bush 下：</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ssh-keygen -t rsa -C "你的GitHub注册邮箱"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后一直回车，默认不需要密码，最后得到了两个文件 id_rsa 和 id_rsa.pub。</p>
<h3 id="拷贝密钥到-GitHub"><a href="#拷贝密钥到-GitHub" class="headerlink" title="拷贝密钥到 GitHub"></a>拷贝密钥到 GitHub</h3><p>打开 id_rsa.pub 文件，将里面的内容全部复制，然后粘贴到 GitHub -&gt; 头像-&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key。</p>
<p>然后测试一下 GitHub SSH，打开 Git Bush ，输入下面的命令</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ssh -T git@github.com
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>看到</p>
<pre><code>Are you sure you want to continue connecting (yes/no)?
</code></pre><p>选择 <code>yes</code></p>
<pre><code>Hi liuzhihan0! You&#39;ve successfully authenticated, but GitHub does not provide shell access.
</code></pre><p>Hi 后面出现你的 GitHub 用户名那么就成功了。</p>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>有了 Node.js ，就可以使用 npm 安装 Hexo ，打开 cmd ，输入以下命令。</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">$ npm install -g hexo-cli
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="使用-Hexo"><a href="#使用-Hexo" class="headerlink" title="使用 Hexo"></a>使用 Hexo</h3><p>安装完成后，先初始化。</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo init foldername
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样就在当前目录下创建了一个名为 foldername 的指定文件夹， Hexo 将会在指定文件夹中新建所需要的文件。</p>
<p>接下来进入 foldername 目录下，输入</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo g # 生成静态页面
hexo s # 在本地预览
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在浏览器中输入 <code>localhost:4000</code> ，就能预览到搭建的博客页面了。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 hexo-deployer-git</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm install hexo-deployer-git --save
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="修改站点配置文件"><a href="#修改站点配置文件" class="headerlink" title="修改站点配置文件"></a>修改站点配置文件</h4><p>修改 foldername 文件下的 <code>_config.yml</code> 的参数。</p>
<p>站点配置文件中 <code>url</code> 和 <code>root</code> 比较容易导致错误，可以像我这样写，最后显示的网址是比如标签页是 <code>https://liuzhihan0.github.io/tags/</code> ，deploy 下必须写上 <code>type: git</code>，repo 的写法是 <code>https://github.com/username/username.github.io</code> ，前面说过这两个 username 是完全相同的。</p>
<pre class="line-numbers language-lang-yml"><code class="language-lang-yml"># URL
url: http://liuzhihan0.github.io
root: /

# ......

deploy:
  type: git
  repo: https://github.com/liuzhihan0/liuzhihan0.github.io.git
  branch: master
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后执行命令</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo d
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在浏览器中输入 username.github.io ，就能看到搭建好的博客了。</p>
<p>以后就可以一点点的完善博客了。</p>
<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo new "文章名称"
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>新建的文章都在 <code>.\source\_posts</code> 目录下，md 格式，可以直接导入。</p>
<p>在本地写好文章后保存，然后执行 <strong>部署三部曲</strong> 更新博客内容：</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo clean
hexo g
hexo d
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当然，执行 <code>hexo d</code> 之前可以先 <code>hexo s</code> 预览一下效果，如果觉得可以了再部署。</p>
<p>这个就是 Hexo 比较麻烦的地方了，它只能在自己的电脑上把文章写好改好，然后再通过命令行终端cmd部署，每次修改都需要重新部署，但是它免费啊，唉，忍忍吧。</p>
<p>写 Markdown 可以用 VScode 或者 Typora 。</p>
<h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo clean
hexo g
hexo s
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="本地调试（-debug）"><a href="#本地调试（-debug）" class="headerlink" title="本地调试（--debug）"></a>本地调试（<code>--debug</code>）</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo clean
hexo g
hexo s --debug
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo clean
hexo g
hexo d
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hexo new "postName"      # 新建文章
hexo new page "pageName" # 新建页面
hexo generate            # 生成静态页面至public目录
hexo server              # 开启预览访问端口(默认端口4000)
hexo deploy              # 项目部署
hexo help                # 查看帮助
hexo version             # 查看Hexo的版本
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="NexT-主题配置"><a href="#NexT-主题配置" class="headerlink" title="NexT 主题配置"></a>NexT 主题配置</h2><h3 id="下载-NexT-主题"><a href="#下载-NexT-主题" class="headerlink" title="下载 NexT 主题"></a>下载 NexT 主题</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">git clone https://github.com/theme-next/hexo-theme-next themes/next
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>themes/next 是安装的相对路径，next是对应的主题文件夹名称。</p>
<h3 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h3><h4 id="版权信息"><a href="#版权信息" class="headerlink" title="版权信息"></a>版权信息</h4><p>找到 creative_commons 改为下面所示。</p>
<pre class="line-numbers language-lang-yml"><code class="language-lang-yml">creative_commons:
  license: by-nc-sa
  sidebar: true
  post: true
  language:
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="NexT-主题的四种样式"><a href="#NexT-主题的四种样式" class="headerlink" title="NexT 主题的四种样式"></a>NexT 主题的四种样式</h4><pre class="line-numbers language-lang-yml"><code class="language-lang-yml"># Schemes
#scheme: Muse
#scheme: Mist
#scheme: Pisces
scheme: Gemini
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="menu-菜单"><a href="#menu-菜单" class="headerlink" title="menu 菜单"></a>menu 菜单</h4><p><code>||</code> 后是图标名称，不要修改。</p>
<pre class="line-numbers language-lang-yml"><code class="language-lang-yml">menu:
  home: / || fa fa-home                     # 首页
  about: /about/ || fa fa-user              # 关于
  tags: /tags/ || fa fa-tags                # 标签
  categories: /categories/ || fa fa-th      # 分类
  archives: /archives/ || fa fa-archive     # 归档
  schedule: /schedule/ || fa fa-calendar    # 日程表
  #sitemap: /sitemap.xml || fa fa-sitemap   # 站点地图
  #commonweal: /404/ || fa fa-heartbeat     # 404页面

# Enable / Disable menu icons / item badges.
menu_settings:
  icons: true
  badges: false
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="作者栏"><a href="#作者栏" class="headerlink" title="作者栏"></a>作者栏</h4><pre class="line-numbers language-lang-yml"><code class="language-lang-yml">avatar:
  # 头像图片路径 \themes\next6\source\images\
  url: /images/author.jpg
  # true为圆形，false为方形
  rounded: true
  # true头像旋转
  rotated: false

# 头像下面的 日志|分类|标签 如果是0则不显示
site_state: true

# 我的其他网站信息
social:
  GitHub: https://github.com/username || fab fa-github
  CSDN: https://blog.csdn.net/xxxxxxx || fa fa-heartbeat

# 显示小图标
social_icons:
  enable: true
  icons_only: false # 是否只显示小图标
  transition: false

# 友链
links_settings:
  icon: fa fa-link
  title: 友情链接
  # Available values: block | inline
  layout: block

links:
  #Title: http://yoursite.com
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h4><p>把自己的收款二维码放到 <code>\themes\next6\source\images\</code> 目录下。</p>
<pre class="line-numbers language-lang-yml"><code class="language-lang-yml">reward_settings:
  # true开启打赏功能
  enable: true
  animation: true
  comment: 感谢支持

reward:
  wechatpay: /images/wechatpay.png
  alipay: /images/alipay.png
  #paypal: /images/paypal.png
  #bitcoin: /images/bitcoin.png
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="右上角显示-GitHub-绑带"><a href="#右上角显示-GitHub-绑带" class="headerlink" title="右上角显示 GitHub 绑带"></a>右上角显示 GitHub 绑带</h4><pre class="line-numbers language-lang-yml"><code class="language-lang-yml">github_banner:
  enable: true
  permalink: https://github.com/liuzhihan0
  title: Follow me on GitHub # 鼠标放到上面显示 title
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="开启不蒜子统计功能"><a href="#开启不蒜子统计功能" class="headerlink" title="开启不蒜子统计功能"></a>开启不蒜子统计功能</h4><pre class="line-numbers language-lang-yml"><code class="language-lang-yml">busuanzi_count:
  enable: true
  total_visitors: true
  total_visitors_icon: fa fa-user
  total_views: true
  total_views_icon: fa fa-eye
  post_views: true
  post_views_icon: fa fa-eye
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="添加本地搜索功能"><a href="#添加本地搜索功能" class="headerlink" title="添加本地搜索功能"></a>添加本地搜索功能</h4><p>安装 hexo-generator-searchdb 插件</p>
<pre><code>$ npm install hexo-generator-searchdb --save
</code></pre><p>打开 _config.yml 找到 local_search ，将 enable 改为 true 。</p>
<pre class="line-numbers language-lang-yml"><code class="language-lang-yml"># 本地搜索
local_search:
  enable: true
  trigger: auto
  top_n_per_article: 1
  unescape: false
  preload: false
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="闪烁之狐主题"><a href="#闪烁之狐主题" class="headerlink" title="闪烁之狐主题"></a>闪烁之狐主题</h2><p>最近换了闪烁之狐这个主题，这是个比较成熟的主题，想要的东西基本都有。<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">Hexo博客主题之hexo-theme-matery的介绍</a></p>
<hr>
<p>如果有什么建议或者文章有需要修改的地方欢迎指出 😁</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章 随机变量的数字特征</title>
    <url>/2020/06/09/probability-theory-4/</url>
    <content><![CDATA[<blockquote>
<p>推荐b站<a href="https://www.bilibili.com/video/BV1ot411y7mU" target="_blank" rel="noopener">《概率论与数理统计》教学视频全集（宋浩）</a></p>
</blockquote>
<h2 id="4-1-随机变量的数学期望"><a href="#4-1-随机变量的数学期望" class="headerlink" title="4.1 随机变量的数学期望"></a>4.1 随机变量的数学期望</h2><p>随机变量的数学期望，也称为随机变量的平均值。数学期望刻画了随机变量取值的平均性质。</p>
<p>随机变量的方差刻画了随机变量取值的波动特性。</p>
<h3 id="4-1-1-离散型随机变量的数学期望"><a href="#4-1-1-离散型随机变量的数学期望" class="headerlink" title="4.1.1 离散型随机变量的数学期望"></a>4.1.1 离散型随机变量的数学期望</h3><p><strong>定义 4.1</strong> 设 $X$ 为离散型随机变量,其分布列为</p>
<script type="math/tex; mode=display">
P(X=x_{i})=p_{i},\qquad i=1,2,\cdots,</script><p>若级数 $\sum_{i=1}^{\infty}x_{i}p_{i}$ 绝对收敛，则称其和为随机变量 $X$ (或其分布)的<strong>数学期望</strong>,简称为<strong>期望</strong>或<strong>均值</strong>,记为 $EX$ ，即</p>
<script type="math/tex; mode=display">
EX=\sum_{i=1}^{\infty}x_{i}p_{i}.</script><p>当级数 $\sum_{i=1}^{\infty}x_{i}p_{i}$ 非绝对收敛时，称随机变量 $X$ (或其分布)的数学期望不存在。</p>
<h3 id="4-1-2-连续型随机变量的数学期望"><a href="#4-1-2-连续型随机变量的数学期望" class="headerlink" title="4.1.2 连续型随机变量的数学期望"></a>4.1.2 连续型随机变量的数学期望</h3><p><strong>定义 4.2</strong> 设随机变量 $X$ 的密度函数为 $f(x)$ ，若积分 $\int_{-\infty}^{+\infty}xf(x)dx$ 绝对收敛，则称其值为 $X$ (或其分布)的<strong>数学期望</strong>，简称为<strong>期望</strong>或<strong>均值</strong>，记为 $EX$ ，即</p>
<script type="math/tex; mode=display">
EX=\int_{-\infty}^{+\infty}xf(x)dx.</script><p>（随机变量 乘 密度函数 求积分）</p>
<h3 id="4-1-3-随机变量函数的数学期望"><a href="#4-1-3-随机变量函数的数学期望" class="headerlink" title="4.1.3 随机变量函数的数学期望"></a>4.1.3 随机变量函数的数学期望</h3><p><strong>定理 4.1</strong> 设 $Y=g(X)$，其中 $X$ 为随机变量，$g(x)$ 为连续函数.</p>
<p>(1) 设<strong>离散型</strong>随机变量 $X$ 的分布列为 $P(X=x_{i})=p_{i},\qquad i=1,2,\cdots$ . 若级数 $\sum_{i=1}^{\infty}g(x_{i}p_{i})$ 绝对收敛，则 $Y=g(X)$ 的数学期望为</p>
<script type="math/tex; mode=display">
EY=E[g(X)]=\sum_{i=1}^{\infty}g(x_i)p_{i}</script><p>(2) 若<strong>连续型</strong>随机变量 $X$ 的密度函数为 $f(x)$，且积分 $\int_{-\infty}^{+\infty}g(x)f(x)dx$ 绝对收敛，则 $Y=g(X)$ 的数学期望为</p>
<script type="math/tex; mode=display">
EY=E[g(X)]=\sum_{i=1}^{\infty}\int_{-\infty}^{+\infty}g(x)f(x)dx</script><p><strong>定理 4.2</strong> 设 $Z=g(X,Y)$，其中 $g(x,y)$ 为二元连续函数.</p>
<p>(1) 若<strong>二维离散型</strong>随机变量  $(X,Y)$  的分布列为 $P(X=x_i,Y=y_i)=p_{ij},\; i,j=1,2,\cdots$，且级数 $\sum_{i=1}^{\infty}\sum_{j=1}^{\infty}g(x_i,y_i)p_{ij}$ 绝对收敛，则</p>
<script type="math/tex; mode=display">
EZ=E[g(X,Y)]=\sum_{i=1}^{\infty}\sum_{j=1}^{\infty}g(x_i,y_i)p_{ij}</script><p>(2) 若<strong>二维连续型</strong>随机变量  $(X,Y)$  的密度函数为 $f(x,y)$，且积分 $\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}g(x,y)f(x,y)dxdy$ 绝对收敛，则</p>
<script type="math/tex; mode=display">
EZ=E[g(X,Y)]=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}g(x,y)f(x,y)dxdy</script><p>特别地，当 $(X,Y)$ 是连续型随机变量时，X，Y 的数学期望分别为</p>
<script type="math/tex; mode=display">
EX=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}xf(x,y)dxdy</script><script type="math/tex; mode=display">
EY=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}yf(x,y)dxdy</script><h3 id="4-1-4-数学期望的性质"><a href="#4-1-4-数学期望的性质" class="headerlink" title="4.1.4 数学期望的性质"></a>4.1.4 数学期望的性质</h3><p>设 $X,Y$ 为随机变量，且 $EX,EY$ 存在.</p>
<ul>
<li><p>$EC=C$.</p>
</li>
<li><p>$E(aX+bY)=aEX+bEY$.</p>
</li>
<li>$E(aX)=aEX, E(X+Y)=EX+EY$.</li>
<li><p>$E(kX+b)=kEX+b$</p>
</li>
<li><p>若 $X,Y$ 相互<strong>独立</strong>，则有 $E(XY)=(EX)(EY)$.</p>
</li>
<li><p>若 $X\geq 0$，则有 $EX \geq 0$；若 $X\leq Y$，则有 $EX \leq EY$.</p>
</li>
<li><p>$|EX|\leq E|X|$ .</p>
</li>
</ul>
<h2 id="4-2-随机变量的方差"><a href="#4-2-随机变量的方差" class="headerlink" title="4.2 随机变量的方差"></a>4.2 随机变量的方差</h2><h3 id="方差的的定义"><a href="#方差的的定义" class="headerlink" title="方差的的定义"></a>方差的的定义</h3><p><strong>定义 4.3</strong> 设 $X$ 为随机变量,若 $E(X-EX)^2$ 存在，则称它为随机变量 $X$ 的<strong>方差</strong>，记为 $DX$ 。即</p>
<script type="math/tex; mode=display">
DX=E(X-EX)^2</script><p>而 $\sqrt{DX}$ 称为随机变量 $X$ 的<strong>标准差</strong>或<strong>均方差</strong>.</p>
<p><strong>离散型：</strong> $DX=\sum_{k}(x_k-EX)^{2}p_k$</p>
<p><strong>连续型</strong>： $DX=\int_{-\infty}^{+\infty}(x-EX)^2f(x)dx$</p>
<p><strong>常用的</strong>计算随机变量方差的<strong>另一公式</strong>：</p>
<script type="math/tex; mode=display">
DX=E(X^2)-(EX)^2</script><h3 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h3><ul>
<li>$DC=0$</li>
<li>对任一随机变量 $X$ 有 $DX\geq 0$. $DX=0$ 的<strong>充要条件</strong>是存在常数 C, 使得 $P(X=C)=1$.</li>
<li>$D(CX+b)=C^2DX$</li>
<li>$D(X\pm Y)=DX+DY\pm 2E[(X-EX)(Y-EY)]$</li>
<li>特别地，若 X 与 Y <strong>独立</strong>，则有 $D(X\pm Y)=DX+DY$ （注意最后一定是+）</li>
<li>对任意常数 $C\neq EX$，有 $DX=E(X-EX)^2&lt;E(X-C)^2$</li>
</ul>
<p><strong>标准化：</strong></p>
<script type="math/tex; mode=display">
X^*=\frac{X-EX}{\sqrt{DX}}</script><script type="math/tex; mode=display">
EX^*=0</script><script type="math/tex; mode=display">
DX^*=1</script><script type="math/tex; mode=display">
证明：EX^*=E(\frac{X-EX}{\sqrt{DX}})=\frac{1}{\sqrt{DX}}(EX-EX)=0</script><script type="math/tex; mode=display">
证明：DX^*=\frac{1}{DX}D(X-EX)=\frac{DX}{DX}=1</script><h2 id="常见分布的期望和方差："><a href="#常见分布的期望和方差：" class="headerlink" title="常见分布的期望和方差："></a>常见分布的期望和方差：</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">分布</th>
<th style="text-align:center">定义</th>
<th style="text-align:center">EX</th>
<th style="text-align:center">DX</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0-1分布</td>
<td style="text-align:center">$P(X=k)=p^k(1-p)^{1-k}，k=0,1,2,\cdots$</td>
<td style="text-align:center">$p$</td>
<td style="text-align:center">$pq$</td>
</tr>
<tr>
<td style="text-align:center">二项分布 $B(n,p)$</td>
<td style="text-align:center">$P(X=k)=C_n^k p^kq_{n-k}，k=0,1,2,\cdots$</td>
<td style="text-align:center">$np$</td>
<td style="text-align:center">$npq$</td>
</tr>
<tr>
<td style="text-align:center">几何分布 $G(p)(1&lt;p&lt;1)$</td>
<td style="text-align:center">$P(X=k)=(1-p)^{k-1}p，k=1,2,\cdots$</td>
<td style="text-align:center">$\frac{1}{p}$</td>
<td style="text-align:center">$\frac{1-p}{p^2}$</td>
</tr>
<tr>
<td style="text-align:center">泊松分布 $P(\lambda)(\lambda&gt;0)$</td>
<td style="text-align:center">$P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda}，k=0,1,2,\cdots$</td>
<td style="text-align:center">$\lambda$</td>
<td style="text-align:center">$\lambda$</td>
</tr>
<tr>
<td style="text-align:center">均匀分布</td>
<td style="text-align:center">$f(x)=\begin{cases} \frac{1}{b-a}, &amp; x\in [a,b] \\ 0, &amp; else \end{cases}$</td>
<td style="text-align:center">$\frac{a+b}{2}$</td>
<td style="text-align:center">$\frac{(b-a)^2}{12}$</td>
</tr>
<tr>
<td style="text-align:center">指数分布 $E(\lambda)(\lambda&gt;0)$</td>
<td style="text-align:center">$f(x)=\begin{cases} \lambda e^{-\lambda x}, &amp; x&gt;0 \\ 0, &amp; else \end{cases}$</td>
<td style="text-align:center">$\frac{1}{\lambda}$</td>
<td style="text-align:center">$\frac{1}{\lambda ^2}$</td>
</tr>
<tr>
<td style="text-align:center">正态分布 $N(\mu,\sigma ^2)(\sigma&gt;0)$</td>
<td style="text-align:center">$N(\mu,\sigma ^2)(\sigma&gt;0)$</td>
<td style="text-align:center">$\mu$</td>
<td style="text-align:center">$\sigma ^2$</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title>测试</title>
    <url>/2020/05/29/test/</url>
    <content><![CDATA[<p>测试</p>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">print('Hello World!')
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</a></p>
</blockquote>
<h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">配置选项</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">title</td>
<td style="text-align:left"><code>Markdown</code> 的文件标题</td>
<td style="text-align:left">文章标题，强烈建议填写此选项</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">文件创建时的日期时间</td>
<td style="text-align:left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td>
</tr>
<tr>
<td style="text-align:left">author</td>
<td style="text-align:left">根 <code>_config.yml</code> 中的 <code>author</code></td>
<td style="text-align:left">文章作者</td>
</tr>
<tr>
<td style="text-align:left">img</td>
<td style="text-align:left"><code>featureImages</code> 中的某个值</td>
<td style="text-align:left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td>
</tr>
<tr>
<td style="text-align:left">cover</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left"><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td>
</tr>
<tr>
<td style="text-align:left">coverImg</td>
<td style="text-align:left">无</td>
<td style="text-align:left"><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">无</td>
<td style="text-align:left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td>
</tr>
<tr>
<td style="text-align:left">toc</td>
<td style="text-align:left"><code>true</code></td>
<td style="text-align:left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td>
</tr>
<tr>
<td style="text-align:left">mathjax</td>
<td style="text-align:left"><code>false</code></td>
<td style="text-align:left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td>
</tr>
<tr>
<td style="text-align:left">summary</td>
<td style="text-align:left">无</td>
<td style="text-align:left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td>
</tr>
<tr>
<td style="text-align:left">categories</td>
<td style="text-align:left">无</td>
<td style="text-align:left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td>
</tr>
<tr>
<td style="text-align:left">tags</td>
<td style="text-align:left">无</td>
<td style="text-align:left">文章标签，一篇文章可以多个标签</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>注意</strong>:</p>
<ol>
<li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li>
<li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li>
<li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li>
</ol>
</blockquote>
<h3 id="最全实例"><a href="#最全实例" class="headerlink" title="最全实例"></a>最全实例</h3><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">---
title: typora
date: 2020-01-01 00:00:00
author: A
img: /source/images/xxx.jpg
top: true
cover: true
coverImg: /images/1.jpg
password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92
toc: false
mathjax: true
summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要
categories: Markdown
tags:
  - Typora
  - Markdown
---
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常用模板</p>
<pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">---
title: typora
date: 2020-01-01 00:00:00
author: A
top: false
cover: true
password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92
toc: false
mathjax: true
summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要
categories: Markdown
tags:
  - Typora
  - Markdown
---
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础学习笔记-MOOC</title>
    <url>/2020/04/24/python-basics/</url>
    <content><![CDATA[<p>之前在中国大学慕课MOOC上看嵩天老师的Python语言程序设计慕课，看视频的过程中把学的基础知识做了笔记</p>
<h2 id="Python-pip-安装与使用"><a href="#Python-pip-安装与使用" class="headerlink" title="Python pip 安装与使用"></a>Python pip 安装与使用</h2><blockquote>
<p><a href="https://pypi.org/project/pip/" target="_blank" rel="noopener">pip 官网</a> </p>
<p><a href="https://www.runoob.com/w3cnote/python-pip-install-usage.html" target="_blank" rel="noopener">Python pip 安装与使用 | 菜鸟教程</a></p>
</blockquote>
<h3 id="pip安装库使用豆瓣镜像源"><a href="#pip安装库使用豆瓣镜像源" class="headerlink" title="pip安装库使用豆瓣镜像源"></a>pip安装库使用豆瓣镜像源</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">pip install name -i http://pypi.douban.com/simple --trusted-host
pypi.douban.com
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<hr>
<h2 id="实例1：温度转换"><a href="#实例1：温度转换" class="headerlink" title="实例1：温度转换"></a>实例1：温度转换</h2><pre class="line-numbers language-lang-python"><code class="language-lang-python"># TempConvert.py
TempStr = input("请输入带有符号的温度值：")
if TempStr[-1] in ['F', 'f']:
    C = (eval(TempStr[0:-1]) - 32) / 1.8
    print("转换后的温度是{:.2f}C".format(C))
elif TempStr[-1] in ['C', 'c']:
    F = 1.8 * eval(TempStr[0:-1]) + 32
    print("转换后的温度是{:.2f}F".format(F))
else:
    print("输入格式错误")
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p><strong>缩进</strong> 表达程序的框架</p>
<ol>
<li>严格明确 缩进是语法的一部分，缩进不正确程序运行错误</li>
<li>所属关系 表达代码间包含和层次关系的唯一手段</li>
<li>长度一致 程序内一致即可，一般用4个空格或1个Tab</li>
</ol>
</li>
<li><p><strong>注释</strong></p>
<ol>
<li>单行注释 以#开头，其后内容为注释信息</li>
<li>多行注释 以’’’开头和结尾</li>
</ol>
</li>
<li><p><strong>变量</strong> 用来保存和保存数据的占位符</p>
<ol>
<li>变量采用标识符（名字）来表示，关联标识符的过程叫命名</li>
<li>可以使用等号（=）向变量赋值或修改值，=被称为赋值符号</li>
</ol>
</li>
<li><p><strong>命名</strong></p>
<ol>
<li>命名规则 大小写字母、数字、下划线和汉字等字符及组合</li>
<li>注意事项 大小写敏感、首字母不能是数字、不与保留字相同</li>
</ol>
</li>
<li><p><strong>保留字</strong> 被编程语言内部定义并保留使用的标识符（33个保留字）  </p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">and</td>
<td style="text-align:center">as</td>
<td style="text-align:center">assert</td>
<td style="text-align:center">break</td>
<td style="text-align:center">class</td>
<td style="text-align:center">continue</td>
</tr>
<tr>
<td style="text-align:center">def</td>
<td style="text-align:center">elif</td>
<td style="text-align:center">else</td>
<td style="text-align:center">except</td>
<td style="text-align:center">finally</td>
<td style="text-align:center">for</td>
</tr>
<tr>
<td style="text-align:center">from</td>
<td style="text-align:center">if</td>
<td style="text-align:center">import</td>
<td style="text-align:center">in</td>
<td style="text-align:center">is</td>
<td style="text-align:center">lambda</td>
</tr>
<tr>
<td style="text-align:center">not</td>
<td style="text-align:center">or</td>
<td style="text-align:center">pass</td>
<td style="text-align:center">raise</td>
<td style="text-align:center">return</td>
<td style="text-align:center">try</td>
</tr>
<tr>
<td style="text-align:center">while</td>
<td style="text-align:center">with</td>
<td style="text-align:center">yield</td>
<td style="text-align:center">del</td>
<td style="text-align:center">global</td>
<td style="text-align:center">nonlocal</td>
</tr>
<tr>
<td style="text-align:center">True</td>
<td style="text-align:center">False</td>
<td style="text-align:center">None</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>数据类型</strong></p>
<ol>
<li>数字类型<ul>
<li>整数</li>
<li>浮点数</li>
</ul>
</li>
<li>字符串类型 由0个或多个字符组成的有序字符序列<ul>
<li>字符串由一对单引号或一对双引号表示</li>
<li>字符串是字符的有序序列，可以对其中的字符进行索引</li>
</ul>
</li>
<li>字符串的序号  <ul>
<li>正向递增序号（开头是0，向后递增）</li>
<li>反向递减序号（末尾是-1，一直向前递减）</li>
</ul>
</li>
<li>字符串的使用 使用[]获取字符串中一个或多个字符<ul>
<li>索引：返回字符串中单个字符 &lt;字符串&gt;[M] 例如<code>&quot;请输入:&quot;[0]</code>、<code>TempStr[-1]</code></li>
<li>切片：返回字符串中一段字符子串 &lt;字符串&gt;[M:N] 例如<code>&quot;请输入:&quot;[1:3]</code>、<code>TempStr[0:-1]</code></li>
</ul>
</li>
<li>列表类型 由0个或多个数据组成的有序序列<ul>
<li>列表使用[]表示，采用逗号(,)分隔各元素</li>
<li>使用保留字 <code>in</code> 判断一个元素是否在列表中</li>
</ul>
</li>
</ol>
</li>
<li><p>语句和函数</p>
</li>
<li><p>赋值语句</p>
<ol>
<li>赋值语句用来给变量赋予新的数据值</li>
<li>赋值语句右侧的数据类型同时作用于变量</li>
</ol>
</li>
<li><p>Python程序的输入输出</p>
<ol>
<li>输入函数input() 从控制台获得用户输入的函数<ul>
<li>input()函数的使用格式：<code>&lt;变量&gt; = input(&lt;提示信息字符串&gt;)</code></li>
<li>用户输入的信息已字符串类型保存在&lt;变量&gt;中</li>
</ul>
</li>
<li>输出函数print() 以字符形式向控制台输出结果的函数<ul>
<li>print()函数的基本使用格式：print(&lt;拟输出字符串或字符串变量&gt;)</li>
<li>print()函数的格式化：<code>print(&quot;转换后的温度是{:.2f}C&quot;.format(C))</code>， <code>{}</code> 表示槽，后序变量填充到槽中，{:.2f}表示将变量C填充到这个位置时取小数点后2位  </li>
</ul>
</li>
</ol>
</li>
<li><p>评估函数eval() 去掉参数最外侧引号并执行余下语句的函数，基本使用格式：<code>eval(&lt;字符串或字符串变量&gt;)</code>  </p>
</li>
</ul>
<hr>
<h2 id="实例2：Python蟒蛇绘制"><a href="#实例2：Python蟒蛇绘制" class="headerlink" title="实例2：Python蟒蛇绘制"></a>实例2：Python蟒蛇绘制</h2><pre class="line-numbers language-lang-python"><code class="language-lang-python">#PythonDraw.py
import turtle
turtle.setup(650, 350, 200, 200)
turtle.penup()
turtle.fd(-250)
turtle.pendown()
turtle.pensize(25)
turtle.pencolor("purple")
turtle.seth(-40)
for i in range(4)
   turtle.circle(40, 80)
   turtle.circle(-40, 80)
turtle.circle(40, 80/2)
turtle.fd(40)
turtle.circle(16, 180)
turtle.fd(40 * 2/3)
turtle.done()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>import</code>保留字引入了一个绘图库，名字叫<code>turtle</code></p>
<h3 id="turtle库的使用"><a href="#turtle库的使用" class="headerlink" title="turtle库的使用"></a>turtle库的使用</h3><p>turtle(海龟)库是turtle绘图体系的Python实现，turtle绘图体系诞生于1969年，主要用于程序设计入门，是Python语言的<strong>标准库</strong>之一，是入门级的图形绘制函数库。</p>
<ul>
<li>标准库<br>Python计生态 = 标准库 + 第三方库<br>标准库：随解释器直接安装到操作系统中的功能模块<br>第三方库：需要经过安装才能使用的功能模块<br>库Library、包Package、模块Module，统称<strong>模块</strong></li>
</ul>
<p>turtle绘制窗体布局</p>
<ul>
<li>绘制turtle图形，首先需要一个绘图窗体，在操作系统上表现为一个窗口，它是turtle的一个画布空间，在窗口中使用的最小单位是像素</li>
<li><code>turtle.setup(width, height, startx, starty)</code><br>设置窗体大小和位置，4个参数后两个可选，setup()不是必须的，若没有后两个参数，那么系统会默认该窗口在屏幕正中心</li>
</ul>
<p>turtle空间坐标体系（绝对坐标 &amp; 海龟坐标）</p>
<ul>
<li><code>turtle.goto(x, y)</code>  让海龟到达某一个坐标位置</li>
<li>海龟坐标<br>以海龟自身的运动方向为参照，对于海龟来讲它的当前行进方向为<strong>前进方向</strong>，反方向为<strong>后退方向</strong>，海龟运行的左侧叫<strong>左侧方向</strong>，右侧叫<strong>右侧方向</strong><ul>
<li><code>turtle.fd(d)</code> 前进</li>
<li><code>turtle.bk(d)</code> 后退</li>
<li><code>turtle.circle(r,angle)</code> 以海龟当前位置的左侧距离为r的点为圆心进行角度为angle的曲线运动</li>
</ul>
</li>
</ul>
<p>turtle的角度坐标体系</p>
<ul>
<li><strong>绝对角度</strong> 可以用<code>turtle.seth(angle)</code>来改变海龟的行进角度，注意<code>seth()</code>只改变方向但不前进，<code>angle</code>为绝对度数<br><code>turtle.setheading(angle)</code> 别名 <code>turtle.seth(angle)</code></li>
<li><strong>海龟角度</strong><ul>
<li><code>turtle.left(angle)</code> 向左旋转<code>angle</code>度</li>
<li><code>turtle.right(angle)</code> 向右旋转<code>angle</code>度 注意只改变角度但不改变位置</li>
</ul>
</li>
</ul>
<h3 id="RGB色彩体系"><a href="#RGB色彩体系" class="headerlink" title="RGB色彩体系"></a>RGB色彩体系</h3><p>由三种颜色构成万物色<br>RGB指红蓝绿三个通道的颜色组合，覆盖视力所能感知的所有颜色，RGB每色取值范围0-255整数或0-1小数<br>turtle库默认采用RGB的小数值来表示颜色，当然也可以使用整数值来表示颜色<br><code>turtle.colormode(mode)</code> 切换RGB色彩模式，1.0：RGB小数模式，255：RGB整数模式</p>
<p>画笔控制函数</p>
<ul>
<li><code>turtle.penup()</code></li>
<li><code>turtle.pendown()</code></li>
<li><code>turtle.pensize(width)</code></li>
<li><code>turtle.pencolor(colorstring)</code> 改变画笔颜色有三种写法 字符串</li>
<li><code>turtle.pencolor(r,g,b)</code>   数值</li>
<li><code>turtle.pencolor((r,g,b))</code> 元组</li>
</ul>
<h3 id="循环语句和range-函数"><a href="#循环语句和range-函数" class="headerlink" title="循环语句和range()函数"></a>循环语句和range()函数</h3><p>循环语句 按照一定次数循环执行一组语句</p>
<p>for &lt;变量&gt; in range(&lt;参数&gt;):<br>&lt;被循环执行的语句&gt;</p>
<p><code>range()</code>函数</p>
<ul>
<li>range(N) 产生0到N-1的整数序列，共N个</li>
<li>range(M,N) 产生M到N-1的整数序列，共N-M个</li>
</ul>
<hr>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><ul>
<li>可正可负，没有取值范围限制</li>
<li><code>pow(x,y)</code>函数：计算 $x^y$，想算多打算多大</li>
<li>4种进制表示形式<ul>
<li>十进制</li>
<li>二进制，以0b或0B开头</li>
<li>八进制，以0o或0O开头</li>
<li>十六进制，以0x或0X开头</li>
</ul>
</li>
</ul>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>与数学中实数的概念一致</p>
<ul>
<li>带有小数点及小数的数字</li>
<li>浮点数取值范围和小数精度都存在限制，但常规计算可忽略</li>
<li>取值范围数量级约 ${-10}^{308}$ 至 ${10}^{308}$，精度数量级 ${10}^{-16}$</li>
<li>浮点数间运算存在不确定尾数，这不是bug</li>
<li><code>round(x,d)</code>，对x四舍五入，d是小数截取位数</li>
<li>浮点数间运算及比较用round()函数辅助</li>
<li>不确定尾数一般发生在 $10^{-16}$ 左右，round()十分有效</li>
</ul>
<h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p>与数学中的复数概念一致</p>
<ul>
<li>定义 $j=\sqrt{-1}$ ，以此为基础，构建数学体系</li>
<li>$a+bj$ 被称为复数，其中a是实部，b是虚部</li>
</ul>
<p>复数实例 $z=1.23e-4+5.6e+89j$</p>
<ul>
<li><code>z.real</code>获得实部</li>
<li><code>z.imag</code>获得虚部</li>
</ul>
<p>客观讲复数类型在常规的计算机编程中很少使用但是它却是进行空间变换尤其是跟复变函数相关的科学体系中最常用的一种数据类型</p>
<h3 id="数值运算操作符"><a href="#数值运算操作符" class="headerlink" title="数值运算操作符"></a>数值运算操作符</h3><ul>
<li>$x+y$</li>
<li>$x-y$</li>
<li>$x*y$</li>
<li>$x/y$ 除，结果是浮点类型</li>
<li>$x//y$ 整数除，结果是整数</li>
<li>$+x$</li>
<li>$-y$</li>
<li>$x\%y$ 余数，模运算</li>
<li>$x**y$<ul>
<li>幂运算，x的y次幂，$x^y$，与pow(x,y)的效果一样</li>
<li>当y是小数时，开方运算，10**0.5的结果是$\sqrt{10}$</li>
</ul>
</li>
<li>$x+=y$</li>
<li>$x-=y$</li>
<li>$x*=y$</li>
<li>$x/=y$</li>
<li>$x//=y$</li>
<li>$x\%=y$</li>
<li>$x**=y$</li>
</ul>
<p>不同数字类型间可进行混合运算，生成结果为“最宽”类型<br>三种类型存在一种逐渐“扩展”或“变宽”的关系：整数 -&gt; 浮点数 -&gt; 复数</p>
<h3 id="数值运算函数"><a href="#数值运算函数" class="headerlink" title="数值运算函数"></a>数值运算函数</h3><ul>
<li><code>abs(x)</code>，绝对值，x的绝对值</li>
<li><code>divmod(x,y)</code>，商余，(x//y,x%y)，同时输出商和余数，例如 <code>divmod(10,3)</code>，结果为<code>(3,1)</code></li>
<li><code>pow(x,y[,z])</code>，幂余，(x**y)%z，[..]表示参数z可省略</li>
<li><code>round(x[,d])</code>，四舍五入，d是保留小数位数，默认值为0，也就是取整</li>
<li><code>max(x1,x2,...,xn)</code>，返回最大值，n不限</li>
<li><code>min(x1,x2,...,xn)</code>，返回最小值，n不限</li>
<li><code>int(x)</code>，将x变成整数，舍弃小数部分</li>
<li><code>float(x)</code>，将x变成浮点数，增加小数部分</li>
<li><code>complex(x)</code>，将x变成复数，增加虚数部分</li>
</ul>
<hr>
<h2 id="实例3"><a href="#实例3" class="headerlink" title="实例3"></a>实例3</h2><pre class="line-numbers language-lang-python"><code class="language-lang-python">#DayDayUp.py
dayup = pow(1.001, 365)
daydown = pow(0.999, 365)
print("向上:{:.2f}, 向下:{:.2f}".format(dayup, daydown))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>运行结果</p>
<p>向上:1.44, 向下:0.69</p>
</blockquote>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">#DayDayUp3.py
dayup = 1.0
dayfactor = 0.01
for i in range(365):
   if i % 7 in [6,0]:
      dayup = dayup * (1 - dayfactor)
   else:
      dayup = dayup * (1 + dayfactor)
print("工作日的力量:{:.2f}".format(dayup))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">#DayDayUp4.py
def dayUP(df):
   dayup = 1
   for i in range(365):
      if i % 7 in [6,0]:
         dayup = dayup * (1 - 0.01)
      else:
         dayup = dayup * (1 + df)
   return dayup
dayfactor = 0.01
while dayUP(dayfactor) < 37.78:
   dayfactor += 0.001
print("工作日的努力参数是:{:.2f}".format(dayfactor))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="字符串类型及操作"><a href="#字符串类型及操作" class="headerlink" title="字符串类型及操作"></a>字符串类型及操作</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串有2类共4种 表示方法</p>
<ul>
<li>如果希望在字符串中出现单引号，那么两侧可以使用双引号来表示字符串，这样其中的单引号就变成了字符</li>
<li>如果希望在字符串中出现双引号，那么两侧可以使用单引号来表示字符串，这样其中的双引号就变成了字符</li>
<li>如果希望在字符串中既出现单引号又出现双引号，可以用三个单引号表示字符串，那么其中出现的一个单引号或者一个双引号就变成了字符串中的字符</li>
</ul>
<h3 id="字符串的序号"><a href="#字符串的序号" class="headerlink" title="字符串的序号"></a>字符串的序号</h3><p>正向递增序号 和 反向递减序号</p>
<h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><blockquote>
<p>索引 和 切片</p>
</blockquote>
<p>使用[]获取字符串中一个或多个字符</p>
<ul>
<li>索引：返回字符串中单个字符 &lt;字符串&gt;[M]</li>
<li>切片：返回字符串中一段字符子串 &lt;字符串&gt;[M:N]</li>
</ul>
<blockquote>
<p>字符串切片高级用法</p>
</blockquote>
<p>使用[M:N:K]根据步长对字符串切片</p>
<ul>
<li>&lt;字符串&gt;[M:N]，M缺失表示<strong>至开头</strong>，N缺失表示<strong>至结尾</strong></li>
<li><p>&lt;字符串&gt;[M:N:K]，根据步长对字符串切片</p>
<ul>
<li><p>例如：</p>
<p>“〇一二三四五六七八九”[1:8:2]结果是”一三五七”  </p>
<p>“〇一二三四五六七八九”[::-1]结果是”十九八七六五四三二一〇”</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串的特殊字符</p>
</blockquote>
<p>转义符 \</p>
<ul>
<li>转义符表达特定字符的本意</li>
</ul>
<blockquote>
<p>字符串操作符</p>
</blockquote>
<ul>
<li><code>x+y</code></li>
<li><code>n*x</code> 或 <code>x*n</code>，n是整数，将字符串x复制n次</li>
<li><code>x in s</code></li>
</ul>
<h3 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h3><blockquote>
<p><code>len(x)</code></p>
</blockquote>
<p>返回字符串长度</p>
<blockquote>
<p><code>str(x)</code></p>
</blockquote>
<p>任意类型x所对应的的字符串形式</p>
<blockquote>
<p><code>hex(x)</code> 或 <code>oct(x)</code></p>
</blockquote>
<p>整数x的十六进制或八进制小写形式字符串</p>
<blockquote>
<p><code>chr(u)</code></p>
</blockquote>
<p>u为Unicode编码，返回其对应的字符</p>
<blockquote>
<p><code>ord(x)</code></p>
</blockquote>
<p>x为字符，返回其对应的Unicode编码</p>
<h3 id="字符串处理方法"><a href="#字符串处理方法" class="headerlink" title="字符串处理方法"></a>字符串处理方法</h3><blockquote>
<p>“方法”在编程中是一个专有名词</p>
</blockquote>
<ul>
<li>“方法”特指<code>&lt;a&gt;.&lt;b&gt;()</code>风格中的函数<code>&lt;b&gt;()</code></li>
<li>方法本身也是函数，但与<code>&lt;a&gt;</code>有关，<code>&lt;a&gt;.&lt;b&gt;()</code>风格使用</li>
<li>字符串及变量也是<code>&lt;a&gt;</code>，存在一些方法</li>
</ul>
<p><code>&lt;a&gt;.&lt;b&gt;()</code>风格是面向对象的一种使用风格，其中a是对象，b是某一个对象能够提供的功能，我们叫方法。方法必须要用 . 的形式来使用</p>
<blockquote>
<p>八个常用的字符串处理方法</p>
</blockquote>
<ul>
<li><code>str.lower()</code>或<code>str.upper()</code>返回字符串的副本，全部字符小写/大写</li>
<li><code>str.split(sep=None)</code>返回一个列表，由str根据sep被分隔的部分组成</li>
<li><code>str.count(sub)</code>返回子串sub在str中出现的次数</li>
<li><code>str.replace(old,new)</code>返回字符串str副本，所有old子串被替换为new</li>
<li><code>str.center(width [,fillchar])</code>字符串str根据宽度width居中，fillchar可选，空余部分填充fillchar</li>
<li><code>str.strip(chars)</code>从str中去掉在其左侧和右侧chars中列出的字符</li>
<li><code>str.join(iter)</code>在iter变量除最后元素外每个元素后增加一个str</li>
</ul>
<h3 id="字符串类型的格式化"><a href="#字符串类型的格式化" class="headerlink" title="字符串类型的格式化"></a>字符串类型的格式化</h3><blockquote>
<p>格式化是对字符串进行格式表达的方法</p>
</blockquote>
<ul>
<li>字符串格式化使用<code>.format()</code>方法<ul>
<li>&lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;)</li>
</ul>
</li>
<li>槽 占位信息符<ul>
<li>使用 <code>{}</code> 表示</li>
</ul>
</li>
</ul>
<blockquote>
<p>format()方法的格式控制</p>
</blockquote>
<p>槽内部对格式化的配置方式<br>{&lt;参数序号&gt;:&lt;格式控制标记&gt;}</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">&lt;填充&gt;</th>
<th style="text-align:center">&lt;对齐&gt;</th>
<th style="text-align:center">&lt;宽度&gt;</th>
<th style="text-align:center">&lt; , &gt;</th>
<th style="text-align:center">&lt;.精度&gt;</th>
<th style="text-align:center">&lt;类型&gt;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">引导符号</td>
<td style="text-align:center">用于填充的单个字符</td>
<td style="text-align:center">&lt;左对齐，&gt;右对齐，^居中对齐</td>
<td style="text-align:center">槽设定的输出宽度</td>
<td style="text-align:center">数字的千位分隔符</td>
<td style="text-align:center">浮点数小数精度 或 字符串的最大输出长度</td>
<td style="text-align:center">整数类型b,c,d,o,x,X 浮点数类型e,E,f,%</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="time库的使用"><a href="#time库的使用" class="headerlink" title="time库的使用"></a>time库的使用</h2><blockquote>
<p>time库是Python中处理时间的标准库</p>
</blockquote>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><ul>
<li><p><code>time()</code> </p>
<p> 获取当前的时间戳，即计算及内部的时间值，浮点数，它表示从1970年1月1日0:00开始到当前这一时刻为止的一个以秒为单位的数值</p>
</li>
<li><p><code>ctime()</code></p>
<p> 获取当前时间并以易读方式表示，返回字符串</p>
</li>
<li><p><code>gmtime()</code></p>
<p> 获取当前时间，表示为计算机可处理的时间格式，我们叫它struct_time格式</p>
</li>
</ul>
<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><ul>
<li><p><code>strftime(tpl,ts)</code></p>
<p>tpl是格式化模板字符串，用来定义输出效果，ts是计算机内部时间类型变量  </p>
</li>
</ul>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">import time
t = time.gmtime()
time.strftime("%Y-%m-%d %H:%M:%S",t)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>结果：<code>&#39;2019-10-23 09:50:37&#39;</code></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格式化字符串</th>
<th style="text-align:center">日期/时间说明</th>
<th style="text-align:center">值范围和实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%Y</td>
<td style="text-align:center">年份</td>
<td style="text-align:center">0000~9999，例如：2019</td>
</tr>
<tr>
<td style="text-align:center">%m</td>
<td style="text-align:center">月份</td>
<td style="text-align:center">01~12，例如：10</td>
</tr>
<tr>
<td style="text-align:center">%B</td>
<td style="text-align:center">月份名称</td>
<td style="text-align:center">January~December，例如：April</td>
</tr>
<tr>
<td style="text-align:center">%b</td>
<td style="text-align:center">月份名称缩写</td>
<td style="text-align:center">Jan~Dec，例如：Apr</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">日期</td>
<td style="text-align:center">01~31，例如：25</td>
</tr>
<tr>
<td style="text-align:center">%A</td>
<td style="text-align:center">星期</td>
<td style="text-align:center">Monday~Sunday，例如：Wednesday</td>
</tr>
<tr>
<td style="text-align:center">%a</td>
<td style="text-align:center">星期缩写</td>
<td style="text-align:center">Mon~Sun，例如：Wed</td>
</tr>
<tr>
<td style="text-align:center">%H</td>
<td style="text-align:center">小时（24h制）</td>
<td style="text-align:center">00~23，例如：12</td>
</tr>
<tr>
<td style="text-align:center">%I</td>
<td style="text-align:center">小时（12h制）</td>
<td style="text-align:center">01~12，例如：7</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:center">上/下午</td>
<td style="text-align:center">AM/pm，例如：PM</td>
</tr>
<tr>
<td style="text-align:center">%M</td>
<td style="text-align:center">分钟</td>
<td style="text-align:center">00~59，例如：26</td>
</tr>
<tr>
<td style="text-align:center">%S</td>
<td style="text-align:center">秒</td>
<td style="text-align:center">00~59，例如：26</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>strptime(str,tpl)</code></p>
<p>str是字符串形式的时间值</p>
<p>tpl是格式化模板字符串，用来定义输入效果</p>
</li>
</ul>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">import time
t = '2019-10-23 09:50:37'
time.strptime(t, "%Y-%m-%d %H:%M:%S")
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>结果：<code>time.struct_time(tm_year=2019, tm_mon=10, tm_mday=23, tm_hour=9, tm_min=50, tm_sec=37, tm_wday=2, tm_yday=296, tm_isdst=-1)</code></p>
</blockquote>
<h3 id="程序计时"><a href="#程序计时" class="headerlink" title="程序计时"></a>程序计时</h3><ul>
<li><p><code>perf_counter()</code></p>
<p>返回一个CPU级别的精确时间计数值，单位为秒，由于这个计数值起点不确定，连续调用差值才有意义</p>
</li>
<li><p><code>sleep(s)</code></p>
<p>s拟休眠的时间，单位是秒，可以是浮点数</p>
</li>
</ul>
<hr>
<h2 id="实例4-文本进度条"><a href="#实例4-文本进度条" class="headerlink" title="实例4 文本进度条"></a>实例4 文本进度条</h2><pre class="line-numbers language-lang-python"><code class="language-lang-python">import time
scale = 50
start = time.perf_counter()
for i in range(scale + 1):
    a = '*' * i
    b = '.' * (scale - i)
    c = (i / scale) * 100
    dur = time.perf_counter() - start
    print("\r{:^3.0f}%[{}->{}] {:.2f}s".format(c, a, b, dur), end="")
    time.sleep(0.1)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<ul>
<li><code>end</code>是<code>print()</code>函数的一个参数，默认情况下不加它指的是我输出了一个信息之后，默认在最后增加一个换行<code>\n</code>，但是如果增加 “<code>,end=</code>” 这样一个参数，就会改变每次print输出最后增加的那个信息  </li>
<li><code>\r</code>指在打印输出字符串前，它能够使光标退回到当前行的行首</li>
</ul>
</blockquote>
<hr>
<h2 id="程序的控制结构"><a href="#程序的控制结构" class="headerlink" title="程序的控制结构"></a>程序的控制结构</h2><blockquote>
<p>顺序结构 分支结构 和 循环结构</p>
</blockquote>
<h3 id="程序的分支结构"><a href="#程序的分支结构" class="headerlink" title="程序的分支结构"></a>程序的分支结构</h3><ul>
<li><p>单分支结构</p>
<p> if &lt;条件&gt;:</p>
<p>   &lt;语句块&gt;</p>
</li>
<li><p>二分支结构</p>
<ul>
<li><p>if &lt;条件&gt;:</p>
<p>&lt;语句块1&gt;</p>
<p>else:</p>
<p> &lt;语句块2&gt;</p>
</li>
<li><p>紧凑形式：&lt;表达式1&gt;if&lt;条件&gt;else&lt;表达式2&gt;</p>
</li>
</ul>
</li>
<li><p>多分支结构</p>
<p> if &lt;条件&gt;:</p>
<p>  &lt;语句块1&gt;</p>
<p> elif:</p>
<p>  &lt;语句块2&gt;</p>
<p> ……</p>
<p> else:</p>
<p>  &lt;语句块3&gt;</p>
</li>
<li><p>条件判断及组合  </p>
<ul>
<li><code>and</code> 与</li>
<li><code>or</code> 或</li>
<li><code>not</code> 非</li>
</ul>
</li>
<li><p>异常处理</p>
<ul>
<li><p>try:</p>
<p>&lt;语句块1&gt;</p>
<p>except:</p>
<p>&lt;语句块2&gt;</p>
</li>
<li><p>try:</p>
<p>&lt;语句块1&gt;</p>
<p>except &lt;异常类型&gt;:</p>
<p>&lt;语句块2&gt;</p>
</li>
<li><p>try:</p>
<p>&lt;语句块1&gt;</p>
<p>except &lt;异常类型&gt;:</p>
<p>&lt;语句块2&gt;</p>
<p>else:</p>
<p>&lt;语句块3&gt;</p>
<p>finally:</p>
<p>&lt;语句块4&gt;</p>
<blockquote>
<p><code>finally</code>对应语句块4一定执行</p>
<p><code>else</code>对应语句块3在不发生异常时执行</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="实例5-身体质量指数"><a href="#实例5-身体质量指数" class="headerlink" title="实例5 身体质量指数"></a>实例5 身体质量指数</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">height, weight = eval(input("请输入身高(米)和体重(公斤)[逗号隔开]"))
bmi = weight / pow(height, 2)
print("BMI指数为：{:.2f}".format(bmi))
who, nat = "", ""
if bmi < 18.5:
   who, nat = "偏瘦", "偏瘦"
elif 18.5 <= bmi < 24:
   who, nat = "正常", "正常"
elif 24 <= 25:
   who, nat = "正常", "偏胖"
elif 25 <= bmi <28:
   who, nat = "偏胖", "偏胖"
elif 28 <= bmi <30:
   who, nat = "偏胖", "偏胖"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="程序的循环结构"><a href="#程序的循环结构" class="headerlink" title="程序的循环结构"></a>程序的循环结构</h3><ul>
<li>遍历循环<code>for</code><ul>
<li>计数循环</li>
<li>字符串遍历循环</li>
<li>列表遍历循环</li>
<li>文件遍历循环</li>
<li>元组</li>
<li>字典</li>
<li>……</li>
</ul>
</li>
<li>无限循环<code>while</code></li>
<li>循环控制保留字<ul>
<li><code>break</code>跳出循环</li>
<li><code>continue</code>继续循环</li>
</ul>
</li>
<li>循环与else<br> 循环正常结束(没有被break强制跳出)时，执行<code>else</code>后的语句块</li>
</ul>
<h3 id="模块3-random库的使用"><a href="#模块3-random库的使用" class="headerlink" title="模块3 random库的使用"></a>模块3 random库的使用</h3><blockquote>
<p>random库是使用随机数的Python标准库</p>
</blockquote>
<ul>
<li>伪随机数：采用梅森旋转算法生成的（伪）随机序列中的元素</li>
<li>random库主要用于生成随机数</li>
<li>使用random库 <code>import random</code></li>
</ul>
<blockquote>
<p>random库包括两类函数，常用共8个</p>
</blockquote>
<ul>
<li>基本随机数序列  <ul>
<li><code>seed(a=None)</code> 初始化给定的随机数种子，默认为当前系统时间</li>
<li><code>random()</code> 生成一个[0.0,1.0]之间的随机小数</li>
</ul>
</li>
<li>扩展随机数序列  <ul>
<li><code>randint(a,b)</code> 生成一个[a,b]之间的整数</li>
<li><code>randrange(m,n [,k])</code> 生成一个[m,n)之间以k为步长的随机整数</li>
<li><code>getrandbits(k)</code> 生成一个k比特长的随机整数</li>
<li><code>uniform(a,b)</code> 生成一个[a,b]之间的随机小数</li>
<li><code>choice(seq)</code> 从序列seq中随机选取一个元素</li>
<li><code>shuffle(seq)</code> 将序列seq中元素随机排列，返回打乱后的序列</li>
</ul>
</li>
</ul>
<h3 id="实例6-圆周率的计算"><a href="#实例6-圆周率的计算" class="headerlink" title="实例6 圆周率的计算"></a>实例6 圆周率的计算</h3><blockquote>
<p>圆周率的近似计算公式</p>
<script type="math/tex; mode=display">
\pi=\sum^{\inf}_{k=0}[\frac{1}{16^k}(\frac{4}{8k+1}-\frac{2}{8k+4}-\frac{1}{8k+5}-\frac{1}{8k+6})]</script><p>蒙特卡罗方法</p>
</blockquote>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">from random import random
from time import perf_counter
DARTS = 1000 * 1000
hits = 0.0
start = perf_counter()
for i in range(1, DARTS + 1):
    x, y = random(), random()
    dist = pow(x ** 2 + y ** 2, 0.5)
    if dist <= 1.0:
        hits += 1
pi = 4 * (hits / DARTS)
print("圆周率是: {}".format(pi))
print("运行时间: {:.5f}s".format(perf_counter() - start))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h2 id="函数和代码复用"><a href="#函数和代码复用" class="headerlink" title="函数和代码复用"></a>函数和代码复用</h2><h3 id="函数的定义与使用"><a href="#函数的定义与使用" class="headerlink" title="函数的定义与使用"></a>函数的定义与使用</h3><ul>
<li><p>函数的定义<code>def</code></p>
</li>
<li><p>可选参数传递 (<strong>赋初值</strong>)</p>
<p> 函数定义时可以为某些参数<strong>指定默认值</strong>，构成可选参数，可选参数必须放必选参数的后面</p>
</li>
</ul>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">#例 可选参数
def fact(n, m=1):
   s = 1
   for i in range(1, n+1):
      s *= i
   return s//m
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>可变参数传递(<code>*b</code>)</p>
<p> 函数接受的参数是可变数量的，即不确定参数总数量</p>
<p> 在确定参数后面增加一个<code>*b</code></p>
</li>
</ul>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">#例 使用可变参数
def fact(n, *b):
   s = 1
   for i in range(1, n+1):
      s *= i
   for item in b:
      s *= item
   return s
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>参数传递的两种方式  <ul>
<li>位置传递</li>
<li>名称传递</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-lang-python"><code class="language-lang-python">#位置传递
fact(10, 5)
#名称传递
fact(m=5, n=10)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>函数的返回值 <code>return</code></p>
<p> 可以返回任意多个结果</p>
</li>
<li><p>局部变量 和 全局变量</p>
<blockquote>
<p>规则1：局部变量和全局变量是不同的</p>
<ul>
<li>局部变量是函数内部的<strong>占位符</strong>，与全局变量可能重名但不同，</li>
<li>函数运算结束后，局部变量被释放</li>
<li>可以使用<code>global</code>保留字在函数内部使用全局变量<br>规则2：局部变量为组合数据类型且未创建，等同于全局变量</li>
</ul>
</blockquote>
</li>
<li><p><code>lambda</code>函数 (不是常用函数定义形式，建议使用<code>def</code>定义的普通函数)</p>
<p> lambda函数是一种匿名函数，返回值是函数名</p>
<p> 形式：&lt;函数名&gt; = lambda&lt;参数&gt;:&lt;表达式&gt;</p>
<p> 举例：</p>
<p> <code>f = lambda x,y : x+y</code></p>
<p> <code>f(10,15)</code></p>
<p> 或</p>
<p> <code>f = lambda : &quot;lambda函数&quot;</code></p>
<p> <code>print(f())</code></p>
</li>
</ul>
<h3 id="实例7：七段数码管绘制"><a href="#实例7：七段数码管绘制" class="headerlink" title="实例7：七段数码管绘制"></a>实例7：七段数码管绘制</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 七段数码管绘制
import turtle, time

def draw_gap():
    turtle.penup()
    turtle.fd(5)

# 绘制单段数码管
def draw_line(draw):
    draw_gap()
    turtle.pendown() if draw else turtle.penup()
    turtle.fd(40)
    draw_gap()
    turtle.right(90)

# 根据数字绘制七段数码管
def draw_digit(digit):
    draw_line(True) if digit in [2, 3, 4, 5, 6, 8, 9] else draw_line(False)
    draw_line(True) if digit in [0, 1, 3, 4, 5, 6, 7, 8, 9] else draw_line(False)
    draw_line(True) if digit in [0, 2, 3, 5, 6, 8, 9] else draw_line(False)
    draw_line(True) if digit in [0, 2, 6, 8] else draw_line(False)
    turtle.left(90)
    draw_line(True) if digit in [0, 4, 5, 6, 8, 9] else draw_line(False)
    draw_line(True) if digit in [0, 2, 3, 5, 6, 7, 8, 9] else draw_line(False)
    draw_line(True) if digit in [0, 1, 2, 3, 4, 7, 8, 9] else draw_line(False)
    turtle.left(180)
    turtle.penup()
    turtle.fd(20)

# 获得要输出的数字
def draw_date(date):
    turtle.pencolor("red")
    for i in date:
        if i == '-':
            turtle.write("年", font=("Arial", 18, "normal"))
            turtle.pencolor("green")
            turtle.fd(40)
        elif i == '=':
            turtle.write("月", font=("Arial", 18, "normal"))
            turtle.pencolor("blue")
            turtle.fd(40)
        elif i == '+':
            turtle.write("日", font=("Arial", 18, "normal"))
        else:
            draw_digit(eval(i))

def main():
    turtle.setup(800, 350, 200, 200)
    turtle.penup()
    turtle.fd(-320)
    turtle.pensize(5)
    str_time = time.strftime("%Y-%m=%d+", time.gmtime())
    # print(str_time)
    draw_date(str_time)
    turtle.hideturtle()
    turtle.done()

if __name__ == '__main__':
    main()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h3 id="代码复用与函数递归"><a href="#代码复用与函数递归" class="headerlink" title="代码复用与函数递归"></a>代码复用与函数递归</h3><ul>
<li>模块化设计思想：松耦合、紧耦合</li>
<li>函数递归的两个特征：基例和链条</li>
</ul>
<pre class="line-numbers language-lang-python"><code class="language-lang-python"># 汉诺塔 递归实现
count = 0

def hanoi(n, src, dst, mid):
    global count
    if n == 1:
        print("{}:{}->{}".format(1, src, dst))
        count += 1
    else:
        hanoi(n - 1, src, mid, dst)
        print("{}:{}->{}".format(n, src, dst))
        count += 1
        hanoi(n - 1, mid, dst, src)

if __name__ == '__main__':
    x = int(input())
    hanoi(x, 'A', 'C', 'B')
    print(count)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="模块4：pyinstaller库的使用"><a href="#模块4：pyinstaller库的使用" class="headerlink" title="模块4：pyinstaller库的使用"></a>模块4：pyinstaller库的使用</h3><blockquote>
<p>将.py源代码转换成无需原代码的可执行文件<br>pyinstaller是第三方库</p>
</blockquote>
<h4 id="安装：打开-cmd"><a href="#安装：打开-cmd" class="headerlink" title="安装：打开 cmd"></a>安装：打开 cmd</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">pip3 install pyinstaller
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">pyinstaller -F <文件名.py>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>执行命令后打开目录，会看到另外生成的三个目录 <strong>__pycache__</strong> , <strong>build</strong> , <strong>dist</strong> ，然后 <strong>__pycache__</strong> , <strong>build</strong> 这两个目录可以安全地删除。在 <code>dist</code> 文件夹中会看到与 .py 文件同名的 exe 文件，这个文件就是打包之后生成的文件。</p>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><ol>
<li><p><code>-h</code> 查看帮助</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash"> pyinstaller -h
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><code>--clean</code> 清理打包过程中的临时文件</p>
<p> 使用 <code>pyinstaller</code> 是加上参数 <code>--clean</code> ，比如产生的 <strong>__pycache__</strong> 和 <strong>build</strong> 文件夹等其他的没用的文件都会被清理掉。</p>
</li>
<li><p><code>-D</code> 默认值，生成dist文件夹</p>
<p> 通过加 <code>-D</code> 参数或者什么都不加，生成dist文件夹，这个文件夹中的所有文件都是必须的。</p>
</li>
<li><p><code>-F</code> 在dist文件夹中只生成独立的打包文件</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash"> pyinstaller -F <文件名.py>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><code>-i &lt;图标名称.ico&gt;</code> 指定打包文件使用的图标文件</p>
<pre class="line-numbers language-lang-bash"><code class="language-lang-bash"> pyinstaller -i <图标名.ico> -F <文件名.py>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<h3 id="实例8：科赫雪花小包裹"><a href="#实例8：科赫雪花小包裹" class="headerlink" title="实例8：科赫雪花小包裹"></a>实例8：科赫雪花小包裹</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 科赫雪花
import turtle

def koch(size, n):
    if n == 0:
        turtle.fd(size)
    else:
        for angle in [0, 60, -120, 60]:
            turtle.left(angle)
            koch(size / 3, n - 1)

def main():
    turtle.setup(600, 600)
    turtle.penup()
    turtle.goto(-200, 100)
    turtle.pendown()
    turtle.pensize(2)
    level = 3
    koch(400, level)
    turtle.right(120)
    koch(400, level)
    turtle.right(120)
    koch(400, level)
    turtle.hideturtle()
    turtle.done()

if __name__ == '__main__':
    main()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
</search>
